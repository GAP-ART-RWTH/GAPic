<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="Chapter_AnimationJavaScript">
<Heading>Animating surfaces with Java Script</Heading>

<P/>
This chapter describes animating simplicial surfaces via Javascript using three.js, see <URL>https://threejs.org/</URL>. Currently this uses r148.
<Section Label="Section_QuickStart">
<Heading>Quick Start</Heading>

This section contains a minimal example by animating an octahedron. To construct an octahedron, we need to specify the 3D-coordinates of its vertices. With this, we can already generate an animation.
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> DrawComplexToJavaScript(oct, "octahedron.html", printRecord);;
]]></Log>

Now, your working directory should contain a file "octahedron.html". This is what it should look like if opened with your browser of choice:<Br/>

<Alt Only="HTML">&lt;br>&lt;img src="../images/Octahedron_animated.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_animated.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check &lt;package location>/doc/images/Octahedron_animated.png]</Alt><Br/>

The method <K>DrawComplexToJavaScript</K> (Section <Ref Sect="Section_basicCommands"/>) generates this .html file. It does this using a configuration saved in a so called <A>printRecord</A>. This <A>printRecord</A> containes at least the 3D-coordinates (as lists with three float entries) of the vertices. Based on these 3D-coordinates of the vertices, the complex is placed in the animation. Therefore, a typical workflow to animate a complex would look like this:
<Enum>
  <Item>Construct the complex as triangular complex object from the <A>SimplicialSurfaces</A> package.</Item>
  <Item>Set the location of the vertices</Item>
  <Item>(Optional) Configure more parameters as described in <Ref Subsect="Section_Colouring"/> and following</Item>
  <Item>Generate the animation as an <A>.html</A> file.</Item>
</Enum>

This file can be opened with most modern browsers and the surface will be shown as a 3D render with some options. More on them in <Ref Subsect="Section_GUI"/>. <Br/>
Because we load the <A>three.js</A> dependencies (and <A>three.js</A> itself) from a content delivery network (CDN) the animation requires an active internet connection. (Some browsers will cache these files so it might work offline but this is not guaranteed)
</Section>

<Section Label="Section_GUI">
<Heading>Output files and the GUI</Heading>

The files generated by <K>DrawComplexToJavaScript</K> have some options that can be changed live in the .html file. 
These are in the so called graphical user interface (GUI), which will look similar to the following
<Alt Only="HTML">&lt;/br>&lt;img src="../images/GUI.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/GUI.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check &lt;package location>/doc/images/GUI.png]</Alt><Br/>

It includes options for the following:
<Enum>
  <Item>Speed of rotation in the X, Y and Z direction</Item>
  <Item>Transparency of the faces that are enabled</Item>
  <Item>Visibility of the edges that are enabled. More in <Ref Subsect="Section_Visibility"/></Item>
  <Item>Visibility of the vertices that are enabled</Item>
  <Item>Visibility of the names (labels) of the vertices that are enabled</Item>
  <Item>Changing the size of the visible vertices (displayed as spheres)</Item>
  <Item>Changing to normalsMaterial. More in <Ref Subsect="Section_NormalsMaterial"/></Item>
  <Item>Visibility of the inner circles. More in <Ref Subsect="Section_InnerCircles"/></Item>
  <Item>Width of the inner circles.</Item>
  <Item>Visibility of the normals of inner circles. More in <Ref Subsect="Section_NormalsInnerCircles"/></Item>
  <Item>(Optional) Any parameters used in the coordinates. More in <Ref Subsect="Section_ParameterizedCoordinates"/></Item>
  <Item>Enabling and moving intersection planes. More in <Ref Subsect="Subsection_IntersectionPlanes"/></Item>
</Enum>

This GUI is implemented using the dat.GUI package from three.js.  
<Subsection Label="Subsection_IntersectionPlanes">
<Heading>Intersection Planes</Heading>
In the GUI there is the option for so called intersection planes. These are three axis aligned planes, that intersect the complete animation and only show one of the sides. <Br/>
This allows to look inside the animation and can be very helpful for example if there are self-intersections or a complex gets fairly big.<Br/>
To activate a plane, toggle the respective checkbox in the GUI. Directly underneath, there is a slider to adjust where the plane should intersect the animation. <Br/>
If the vertex coordinates are not parameterised (<Ref Subsect="Section_ParameterizedCoordinates"/>) the sliders are automatically adjusted so you can intersect the whole complex in X, Y and Z direction. In case you want more precision, either make the GUI larger by dragging on the left of the GUI or change the slider by typing a number in the field next to it.<Br/>
If there are coordinates which are parameterized or you want to change the range of the planes manually, it is possible with the following:
</Subsection>
<ManSection Label="SetPlaneRange">
  <Oper Arg="surface, ranges, printRecord" Name="SetPlaneRange" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Returns>the updated print record
  </Returns>
  <Description>
  Change the range of the intersection planes by giving a list of the <A>ranges</A> as floats in the following format: <A>[[minX, maxX],[minY, maxY],[minZ, maxZ]]</A>
  <P/>
  </Description>
</ManSection>

<ManSection Label="GetPlaneRange">
  <Oper Arg="surface, printRecord" Name="GetPlaneRange" Label="for IsTriangularComplex, IsRecord"/>
  <Returns>a list of lists
  </Returns>
  <Description>
  Returns the plane ranges of the <A>printRecord</A> set with <A>SetPlaneRange</A> in the format <A>[[minX, maxX],[minY, maxY],[minZ, maxZ]]</A> or <A>fail</A> if they are not set (i.e. automatic).
  <P/>
  </Description>
</ManSection>

<Subsection Label="Section_Visibility">
<Heading>Visibility</Heading>

Sometimes parts of the complex should be not visible. In the GUI it is possible to turn all of these off but sometimes it can help if only certain (subsets of) parts of the complex are visible. This can be done for the following things:
<Enum>
  <Item>Vertices (see <Ref Subsect="ActivateVertices"/>) </Item>
  <Item>Edges (see <Ref Subsect="ActivateEdges"/>)</Item>
  <Item>Faces (see <Ref Subsect="ActivateFaces"/>) </Item>
</Enum>
By default, all faces are visible. In the GUI the vertices and edges can also be activated.
In general there is a difference between a visible vertex, edge and face and an active one. If they are active (all of them are by default) then the whole set can be made (in)visible in the GUI without changing the file.<Br/>
If however any (subset) of them are deactivated they will be skipped during the generation of the file. With this it is possible to make parts of the complex visible and others not. However it is currently not possible to activate or deactivate anything in the GUI, once it is set, this property can only be changed by regenerating the file.

We illustrade this functionality by animating an octahedron as before but with only vertices 2 and 3 visible. For this, first all vertices will be deactivated and then only 2 and 3 activated
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := DeactivateVertices(oct, printRecord);;
gap> printRecord := ActivateVertex(oct, 2, printRecord);;
gap> printRecord := ActivateVertex(oct, 3, printRecord);;
gap> # check the visibility of the vertices
gap> List([1..NumberOfVertices(oct)], i -> IsVertexActive(oct, i, printRecord));
[ false, true, true, false, false, false ]
gap> DrawComplexToJavaScript(oct, "octahedron.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_animatedWithoutSomeVertices.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_animatedWithoutSomeVertices.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_animatedWithoutSomeVertices.png]</Alt><Br/>

</Subsection>


<ManSection Label="ActivateVertices">
  <Oper Arg="surface, printRecord" Name="ActivateVertices" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateVertex" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsVertexActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateVertex</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the vertex <A>i</A>.
 If a vertex is active, then the vertex is shown in the animation as a node with the number <A>i</A>.
 The method <K>ActivateVertices</K>(<A>surface</A>, <A>printRecord</A>) activates all vertices of <A>surface</A>.
 By default, all vertices are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateVertices">
  <Oper Arg="surface, printRecord" Name="DeactivateVertices" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateVertex" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateVertex</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the vertex <A>i</A>.
 If a vertex is inactive, then the vertex is not shown and will not be written in the file.
 The method <K>DeactivateVertices</K>(<A>surface</A>, <A>printRecord</A>) deactivates all vertices of <A>surface</A>.
 By default, all vertices are activated.
<P/>
 </Description>
</ManSection>

<ManSection Label="ActivateEdges">
  <Oper Arg="surface, printRecord" Name="ActivateEdges" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateEdge" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsEdgeActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateEdge</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the edge <A>i</A>.
 If an edge is active, then the edge is shown in the animation.
 The method <K>ActivateEdges</K>(<A>surface</A>, <A>printRecord</A>) activates all edges of <A>surface</A>.
 By default, all edges are activated.
<P/>
 </Description>
</ManSection>

<ManSection Label="DeactivateEdges">
  <Oper Arg="surface, printRecord" Name="DeactivateEdges" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateEdge" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateEdge</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the edge <A>i</A>.
 If an edge is inactive, then the edge is not shown in the animation and will not be written in the file.
 The method <K>DeactivateEdge</K>(<A>surface</A>, <A>printRecord</A>) deactivates all edges of <A>surface</A>.
 By default, all edges are activated.
<P/>
 </Description>
</ManSection>

<ManSection Label="ActivateFaces">
  <Oper Arg="surface, printRecord" Name="ActivateFaces" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateFace" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsFaceActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateFace</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the face <A>i</A>.
 If a face is active, then the face is shown in the animation.
 The method <K>ActivateFaces</K>(<A>surface</A>, <A>printRecord</A>) activates all faces of <A>surface</A>.
 By default, all faces are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateFaces">
  <Oper Arg="surface, printRecord" Name="DeactivateFaces" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateFace" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateFace</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the face <A>i</A>.
 If a face is inactive, then the face is not shown in the animation and will not be written in the file.
 The method <K>DeactivateFace</K>(<A>surface</A>, <A>printRecord</A>) deactivates all faces of <A>surface</A>.
 By default, all faces are activated.
<P/>
 </Description>
</ManSection>

</Section>


<Section Label="Section_basicCommands">
<Heading>Basic Commands</Heading>
In this section the options that can be defined by the <A>printRecord</A> will be described. The most important one is how to set coordinates.

<ManSection Label="SetVertexCoordinates3D">
  <Oper Arg="surface, coordinates[, printRecord]" Name="SetVertexCoordinates3D" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, coordinates[, printRecord]" Name="SetVertexCoordinates3DNC" Label="for IsTriangularComplex, IsList, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 Save the given list of 3D-coordinates <A>coordinates</A> in the given or an empty print record if non is provided. The list <A>coordinates</A> has to have entries that are a list <A>[x,y,z]</A> of three floats. If the format of the <A>coordinates</A> is not correct, an error is shown. The NC-version does not check the coordinate format.
<P/>
 </Description>
</ManSection>
Note: for using parameterised vertex coordinates see <Ref Subsect="Section_ParameterizedCoordinates"/>.

<ManSection Label="GetVertexCoordinates3D">
  <Oper Arg="surface, vertex, printRecord" Name="GetVertexCoordinates3D" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, vertex, printRecord" Name="GetVertexCoordinates3DNC" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a list of lists with three floats
</Returns>
 <Description>
 Extract the 3D-coordinates from the print record of the vertex <A>vertex</A> from <A>surface</A>. The 3D-coordinates of vertex <A>vertex</A> has to have the format <A>[x,y,z]</A>. If the format of the <A>coordinates</A> is not correct, then an error is shown. This can happen, if the NC version is used to store the 3D-coordinates. The NC-version does not check the coordinate format saved in the print record.
<P/>
 </Description>
</ManSection>

As decribed before the next important method is the one generating the animations.
<ManSection Label="DrawComplexToJavaScript">
  <Oper Arg="surface, filename, printRecord" Name="DrawComplexToJavaScript" Label="for IsTriangularComplex, IsString, IsRecord"/>
  <Returns>
    the print record
  </Returns>
  <Description>
  This method animates the <A>surface</A> as an .html file <A>filename</A> into the working directory.<Br/>
  An introduction to the use of this method with an example can be found at the start of section <Ref Sect="Section_QuickStart"/>.
  <P/>
  Note:
  <List>
    <Item>
      If the given <A>fileName</A> does not end in <E>.html</E> the ending
      <E>.html</E> will be added to it.
    </Item>
    <Item>
      The given file will be overwritten without asking if it already exists. If you don't have permission to write in that file, this method will throw an error.
    </Item>
    <Item>
      The animation is determined by the given <A>printRecord</A>.
    </Item>
  </List>
  <P/>
  To use these methods it is necessary to set the 3D-coordinates 
  of the vertices of the surface (see <K>SetVertexCoordinates3D</K>).
  <P/>
  </Description>
</ManSection>

 Note, it is also possible to animate simplicial surfaces whose vertices,
 edges and faces are not given by a dense list <K>[1..n]</K>.
 For example the function <K>SetVertexCoordinates3D</K> allows a list of
 3D-coordinates as input that is not dense. But this only works in the case 
 that the 3D-coordinate of vertex <K>i</K> is stored in the <K>i</K>-th
 position of the given list.
<P/>
<Example><![CDATA[
gap> oneFace:=SimplicialSurfaceByDownwardIncidence([,[3,7],,[7,10],,[3,10]],
> [,,[2,4,6]]);;
gap> Vertices(oneFace);
[ 3, 7, 10 ]
gap> coor:=[];;
gap> coor[3]:=[1,0,0];;coor[7]:=[0,1,0];;coor[10]:=[0,0,1];;
gap> printRecord:=SetVertexCoordinates3D(oneFace,coor,rec());;
gap> DrawComplexToJavaScript(oneFace,"OneFace_animating",printRecord);
rec( edgeThickness := 0.03, 
 vertexCoordinates3D := [ ,, [ 1, 0, 0 ],,,, [ 0, 1, 0 ],,, [ 0, 0, 1 ] ] )
]]></Example>

<P/>
<Alt Only="HTML">&lt;img src="../images/OneFace_animated.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/OneFace_animated.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/OneFace_animated.png]</Alt>

</Section>

<Section Label="Section_Colouring">
<Heading>Colouring</Heading>

 In this section, we describe how to colour the animation. The colours are stored in hexadecimal format, which starts with 0x.
 The following possibilities are available:
 <Enum>
   <Item>Vertices (The default colour is 0xF58137, an orange hue. See <Ref Subsect="SetVertexColours"/>)</Item>
   <Item>Edges (The default colour is 0x000000, black. See <Ref Subsect="SetEdgeColours"/>)</Item>
   <Item>Faces (The default colour is 0x049EF4, a light blue hue. See <Ref Subsect="SetFaceColours"/>)</Item>
   <Item>Innercircles. See <Ref Subsect="Section_InnerCircles"/></Item>
 </Enum>
 Here is a brief colouring example:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := SetVertexColours(oct,
> ListWithIdenticalEntries(NumberOfVertices(oct), "green"), printRecord);;
gap> printRecord := SetVertexColour(oct, 3, "red", printRecord);;
gap> List([1..NumberOfVertices(oct)], i -> GetVertexColour(oct, i, printRecord));
[ "green", "green", "red", "green", "green", "green" ]
gap> DrawComplexToJavaScript(oct, "octahedron.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_EdgeColors.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_EdgeColors.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_EdgeColors.png]</Alt><Br/>


<ManSection Label="SetVertexColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetVertexColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetVertexColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetVertexColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of vertex <A>i</A> to <A>colour</A>. The method <K>SetVertexColours</K>(<A>surface</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all vertices of <A>surface</A>. That means the method set the colour of vertex <A>j</A> to <A>newColoursList[j]</A>. The default colour for all vertices is 0xF58137, an orange hue. This color will be shown as a small sphere around the vertex with the option in the GUI to change the radius.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetVertexColours">
  <Oper Arg="surface, printRecord" Name="GetVertexColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetVertexColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a (list) of color values in the format explained here: <Ref Subsect="Section_Colouring"/>
</Returns>
 <Description>
 The method <K>GetVertexColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour of vertex <A>i</A>. The method <K>GetVertexColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colours for all vertices of <A>surface</A> as a list <A>colours</A>, where the colour of vertex <A>j</A> is <A>colours[j]</A>. The default colour for all vertices is 0xF58137, an orange hue.
<P/>
 </Description>
</ManSection>


<ManSection Label="SetEdgeColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetEdgeColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetEdgeColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetEdgeColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of edge <A>i</A> to <A>colour</A>. The method <K>SetEdgeColours</K>(<A>surface</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all edges of <A>surface</A>. That means the method set the colour of edge <A>j</A> to <A>newColoursList[j]</A>. The default colour for all edges is 0x000000, black.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetEdgeColours">
  <Oper Arg="surface, printRecord" Name="GetEdgeColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetEdgeColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>GetEdgeColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour of edge <A>i</A>. The method <K>GetEdgeColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colours for all edges of <A>surface</A> as a list <A>colours</A>, where the colour of edge <A>j</A> is <A>colours[j]</A>.
 The default colour for all edges is 0x000000, black.
<P/>
 </Description>
</ManSection>


<ManSection Label="SetFaceColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetFaceColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetFaceColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetFaceColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of face <A>i</A> to <A>colour</A>. The method <K>SetFaceColours</K>(<A>surface</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all faces of <A>surface</A>. That means the method set the colour of face <A>j</A> to <A>newColoursList[j]</A>. The default colour for all faces is 0x049EF4, a light blue hue.<Br/>
 It is also possible to set the color to a so called normalsMaterial, more in <Ref Subsect="Section_NormalsMaterial"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetFaceColours">
  <Oper Arg="surface, printRecord" Name="GetFaceColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetFaceColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a (list) of color values in the format explained here: <Ref Subsect="Section_Colouring"/>
</Returns>
 <Description>
 The method <K>GetFaceColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour of face <A>i</A>. The method <K>GetFaceColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colours for all faces of <A>surface</A> as a list <A>colours</A>, where the colour of face <A>j</A> is <A>colours[j]</A>. The default colour for all faces is 0x049EF4, a light blue hue.
<P/>
 </Description>
</ManSection>

</Section>


<Section Label="Section_InnerCircles">
<Heading>Inner Circles</Heading>
 Inner circles are defined for triangular faces. In the animation, they are circles within the face that touch each of the three edges in exactly one point, centered at the incenter. By default the innercircles are active but not visible and can be toggled on in the GUI. If the output file should be smaller it can help to disable these as they will not be written into the file if disabled.
<P/>
 As an example, consider the octahedron generated as before:

<Alt Only="HTML">&lt;img src="../images/Octahedron_InnerCircle.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_InnerCircle.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_InnerCircle.png]</Alt><Br/>

<ManSection Label="ActivateInnerCircles">
  <Oper Arg="surface, printRecord" Name="ActivateInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsInnerCircleActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>ActivateInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the inner circle of face <A>i</A>. The method <K>ActivateInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) activates all inner circles of <A>surface</A>. If an inner circle is active, then it is shown in the animation. By default, the inner circles are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateInnerCircles">
  <Oper Arg="surface, printRecord" Name="DeactivateInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>DeactivateInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the inner circle of face <A>i</A>. The method <K>DeactivateInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) deactivates all inner circles of <A>surface</A>. If an inner circle is deactivated, then it is not shown in the animation and will not be written into the file. By default, the inner circles are activated.
<P/>
 </Description>
</ManSection>

It is also possible to set colours for the innercircles. This can be done with the following:
<ManSection Label="SetCircleColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetCircleColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetCircleColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetCircleColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour for the inner circle of face <A>i</A>. The method <K>SetCircleColours</K>(<A>surface</A>, <A>newColoursList</A>, <A>printRecord</A>) sets the colour for all inner circles of <A>surface</A>. That means the method set the colour of the inner circle of face <A>j</A> to <A>newColoursList[j]</A>. The default colour is 0x000000, black.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetCircleColours">
  <Oper Arg="surface, printRecord" Name="GetCircleColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetCircleColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>GetCircleColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour for the inner circle of face <A>i</A>. The method <K>GetCircleColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colour for all inner circles of <A>surface</A> as a list <A>colours</A>, where the colour of the inner circle of face <A>j</A> is <A>colours[j]</A>. The default colour is 0x000000, black.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_NormalsInnerCircles">
<Heading>Normals of Inner Circles</Heading>

<P/>
 A normal of an inner circle (compare Section <Ref Sect="Section_InnerCircles"/>) is a line intersecting the center of the incircle orthogonally or to say in other words it intersects the incenter and extends orthogonally w.r.t. the face in both directions.
<P/>
By default the normals of inner circles are active but invisible and can be toggled on in the GUI. To make the output files smaller it can help to disable them.

Consider the example from before:
<Alt Only="HTML">&lt;img src="../images/Octahedron_NormalsOfInnerCircle.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_NormalsOfInnerCircle.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_NormalsOfInnerCircle.png]</Alt><Br/>

<ManSection Label="ActivateNormalOfInnerCircles">
  <Oper Arg="surface, printRecord" Name="ActivateNormalOfInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateNormalOfInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsNormalOfInnerCircleActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>ActivateNormalOfInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the normal of the inner circle of face <A>i</A>. The method <K>ActivateNormalOfInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) activates all normals of the inner circles of <A>surface</A>. If a normal is active, then the normal is written to the file.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateNormalOfInnerCircles">
  <Oper Arg="surface, printRecord" Name="DeactivateNormalOfInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateNormalOfInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>DeactivateNormalOfInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the normal of the inner circle of face <A>i</A>. The method <K>DeactivateNormalOfInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) deactivates all normals of the inner circles of <A>surface</A>. If a normal is deactivated, then the normal is not shown in the animation.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_NormalsMaterial">
<Heading>NormalsMaterial</Heading>
There is the possibility to render the surface with not the normal material but a so called normalsMaterial. This material computes the color of any face in real time with regards to it's normal vector towards the camera. That way we get a different color if two faces have different normals.
<P/>
It is also possible to change to the normalsMaterial in the GUI, as it will be generated as well. The following is mostly to set a default or change only a (subset) of faces.
<P/>
 Consider the following example:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := SetFaceColour(oct, "normal", printRecord);
gap> DrawComplexToJavaScript(oct, "doc/Octahedron_NormalMaterial.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_normalsMaterial.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_normalsMaterial.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_normalsMaterial.png]</Alt><Br/>

</Section>


<!-- <Section Label="Section_ParameterizedCoordinates">
<Heading>Parameterised Coordinates</Heading>
It is possible to 

</Section> -->

</Chapter>

