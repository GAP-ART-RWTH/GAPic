<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="Chapter_AnimationJavaScript">
<Heading>Animating surfaces with Java Script</Heading>

<P/>
This chapter describes animating simplicial surfaces via Javascript using a 3D library called three.js, see <URL>https://threejs.org/</URL>. Currently this uses r148. This functionality requires the GAP Package <A>SimplicialSurfaces</A>, see <URL>https://github.com/gap-packages/SimplicialSurfaces</URL>. Currently it is possible to animate triagonal complexes, so any triangulated polygon.
<Section Label="Section_QuickStart">
<Heading>Quick Start</Heading>

This section contains a minimal example of animating an octahedron. To construct an octahedron, we need to specify the 3D-coordinates of its vertices. With this, we can already generate an animation.
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> DrawComplexToJavaScript(oct, "octahedron.html", printRecord);;
]]></Log>

Now, your working directory should contain a file "octahedron.html". The following picture will be produced when the file is opened with a browser of your choice:<Br/>

<Alt Only="HTML">&lt;br>&lt;img src="../images/Octahedron_animated.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_animated.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check &lt;package location>/doc/images/Octahedron_animated.png]</Alt>

The method <K>DrawComplexToJavaScript</K> (Section <Ref Sect="Section_basicCommands"/>) generates this .html file. The function requires the argument <A>printRecord</A> where <A>printRecord</A> is a GAP record which containes the 3D-coordinates (as lists with three float entries) of the vertices at a minimum. Based on these 3D-coordinates of the vertices, the complex is placed in the animation. Therefore, a typical workflow to animate a complex would look like this:
<Enum>
  <Item>Construct the complex as triangular complex object from the <A>SimplicialSurfaces</A> package.</Item>
  <Item>Set the location of the vertices</Item>
  <Item>(Optional) Configure more parameters of <A>printRecord</A> as described in <Ref Subsect="Section_Colouring"/> and following</Item>
  <Item>Generate the animation as an <A>.html</A> file using the function <A>DrawComplexToJavaScript</A>.</Item>
</Enum>

This file can be opened with most modern browsers and the complex will be shown as a 3D render with some options. More on them in <Ref Subsect="Section_GUI"/>. Note that the image is interactive, for example it can be rotated by clicking and dragging it with the mouse or touchscreen.<Br/>
Also note, that an active internet connection is required because we load the <A>three.js</A> dependencies (and <A>three.js</A> itself) from a content delivery network (CDN) (Some browsers will cache these files so it might work offline but this is not guaranteed). Due to newer security requirements when using JavaScript libraries it is currently not possible to distribute these files with the package.
</Section>

<Section Label="Section_GUI">
<Heading>Output files and the GUI</Heading>

Some options can be changed live in the graphical user interface (GUI), displayed by the browser which will look similar to the following
<Alt Only="HTML">&lt;/br>&lt;img src="../images/GUI.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/GUI.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check &lt;package location>/doc/images/GUI.png]</Alt>

The options in the GUI influence the way a complex is displayed by the browser and includes options for the following:
<Enum>
  <Item>Speed of rotation in the X, Y and Z directions</Item>
  <Item>Transparency of the faces that are enabled</Item>
  <Item>Visibility of the edges that are enabled. More in <Ref Subsect="Section_Visibility"/></Item>
  <Item>Visibility of the vertices that are enabled</Item>
  <Item>Visibility of the names (labels) of the vertices that are enabled</Item>
  <Item>Changing the size of the visible vertices (displayed as spheres)</Item>
  <Item>Changing to normalsMaterial. More in <Ref Subsect="Section_NormalsMaterial"/></Item>
  <Item>Visibility of the inner circles. More in <Ref Subsect="Section_InnerCircles"/></Item>
  <Item>Width of the inner circles.</Item>
  <Item>Visibility of the normals of inner circles. More in <Ref Subsect="Section_NormalsInnerCircles"/></Item>
  <Item>(Optional) Any parameters used in the coordinates. More in <Ref Subsect="Section_ParameterizedCoordinates"/></Item>
  <Item>Enabling and moving intersection planes. More in <Ref Subsect="Subsection_IntersectionPlanes"/></Item>
</Enum>

This GUI is implemented using the dat.GUI package from three.js.  
<Subsection Label="Subsection_IntersectionPlanes">
<Heading>Intersection Planes</Heading>
The GUI contains an option for enabling intersection planes. These planes aligned with the three axes, intersect the complete animation and only show the part of the animation that lies on one side of the plane. <Br/>
Enabling the intersecting plane option allows to look inside the animation and can be very helpful for example if there are self-intersections or a complex is fairly large.<Br/>
To activate a plane, toggle the respective checkbox in the GUI. Directly underneath, there is a slider to adjust where the plane should intersect the animation. This slider has a minimum and maximum setting, which are called the range of this slider.<Br/>
If the vertex coordinates are not parameterised (<Ref Subsect="Section_ParameterizedCoordinates"/>) the sliders are automatically adjusted to intersect the whole complex in X, Y and Z direction. In case you want more precision, either make the GUI larger by dragging on the left of the GUI or change the slider by typing a number in the field next to it.<Br/>
If there are coordinates which are parameterized or you want to change the range of the planes manually, it is possible with the following:
</Subsection>
<ManSection Label="SetPlaneRange">
  <Oper Arg="complex, ranges, printRecord" Name="SetPlaneRange" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Returns>the updated print record
  </Returns>
  <Description>
  Change the range of the intersection planes by giving a list of the <A>ranges</A> as floats in the following format: <A>[[minX, maxX],[minY, maxY],[minZ, maxZ]]</A>
  <P/>
  </Description>
</ManSection>

<ManSection Label="GetPlaneRange">
  <Oper Arg="complex, printRecord" Name="GetPlaneRange" Label="for IsTriangularComplex, IsRecord"/>
  <Returns>a list of lists
  </Returns>
  <Description>
  Returns the plane ranges of the <A>printRecord</A> set with <A>SetPlaneRange</A> in the format <A>[[minX, maxX],[minY, maxY],[minZ, maxZ]]</A> or <A>fail</A> if they are not set (i.e. automatic).
  <P/>
  </Description>
</ManSection>

<Subsection Label="Section_Visibility">
<Heading>Appearence</Heading>

Sometimes parts of the complex should be not shown in the animation. In the GUI it is possible to turn all vertices/edges/faces off but sometimes it can help if only certain (subsets of) of vertices/edges/faces of the complex are visible. This can be done for the following objects:
<Enum>
  <Item>Vertices (see <Ref Subsect="ActivateVertices"/>) </Item>
  <Item>Edges (see <Ref Subsect="ActivateEdges"/>)</Item>
  <Item>Faces (see <Ref Subsect="ActivateFaces"/>) </Item>
</Enum>
By default, all faces are visible. In the GUI the vertices and edges can also be made visible by checking the respective box.
In general there is a difference between a visible vertex, edge and face and an active one. If they are active (all of them are by default) then the whole set can be made (in)visible in the GUI without changing the file.<Br/>
If however any (subset) of them are deactivated they will be skipped during the generation of the file. With this it is possible to make parts of the complex visible and others not. However it is currently not possible to activate or deactivate anything in the GUI, once it is set, this property can only be changed by regenerating the file.

We illustrade this functionality by animating an octahedron as before but with only vertices 2 and 3 visible. For this, first all vertices will be deactivated and then only 2 and 3 activated
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := DeactivateVertices(oct, printRecord);;
gap> printRecord := ActivateVertex(oct, 2, printRecord);;
gap> printRecord := ActivateVertex(oct, 3, printRecord);;
gap> # check the visibility of the vertices
gap> List([1..NumberOfVertices(oct)], i -> IsVertexActive(oct, i, printRecord));
[ false, true, true, false, false, false ]
gap> DrawComplexToJavaScript(oct, "octahedron.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;/br>&lt;img src="../images/Octahedron_animatedWithoutSomeVertices.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_animatedWithoutSomeVertices.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_animatedWithoutSomeVertices.png]</Alt>

</Subsection>


<ManSection Label="ActivateVertices">
  <Oper Arg="complex, printRecord" Name="ActivateVertices" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="ActivateVertex" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="IsVertexActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateVertex</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) activates the vertex <A>i</A>.
 If a vertex is active, then the vertex is shown in the animation as a node with the number <A>i</A>.
 The method <K>ActivateVertices</K>(<A>complex</A>, <A>printRecord</A>) activates all vertices of <A>complex</A>.
 By default, all vertices are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateVertices">
  <Oper Arg="complex, printRecord" Name="DeactivateVertices" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="DeactivateVertex" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateVertex</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) deactivates the vertex <A>i</A>.
 If a vertex is inactive, then the vertex is not shown and will not be written in the file.
 The method <K>DeactivateVertices</K>(<A>complex</A>, <A>printRecord</A>) deactivates all vertices of <A>complex</A>.
 By default, all vertices are activated.
<P/>
 </Description>
</ManSection>

<ManSection Label="ActivateEdges">
  <Oper Arg="complex, printRecord" Name="ActivateEdges" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="ActivateEdge" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="IsEdgeActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateEdge</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) activates the edge <A>i</A>.
 If an edge is active, then the edge is shown in the animation.
 The method <K>ActivateEdges</K>(<A>complex</A>, <A>printRecord</A>) activates all edges of <A>complex</A>.
 By default, all edges are activated.
<P/>
 </Description>
</ManSection>

<ManSection Label="DeactivateEdges">
  <Oper Arg="complex, printRecord" Name="DeactivateEdges" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="DeactivateEdge" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateEdge</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) deactivates the edge <A>i</A>.
 If an edge is inactive, then the edge is not shown in the animation and will not be written in the file.
 The method <K>DeactivateEdge</K>(<A>complex</A>, <A>printRecord</A>) deactivates all edges of <A>complex</A>.
 By default, all edges are activated.
<P/>
 </Description>
</ManSection>

<ManSection Label="ActivateFaces">
  <Oper Arg="complex, printRecord" Name="ActivateFaces" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="ActivateFace" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="IsFaceActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateFace</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) activates the face <A>i</A>.
 If a face is active, then the face is shown in the animation.
 The method <K>ActivateFaces</K>(<A>complex</A>, <A>printRecord</A>) activates all faces of <A>complex</A>.
 By default, all faces are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateFaces">
  <Oper Arg="complex, printRecord" Name="DeactivateFaces" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="DeactivateFace" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateFace</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) deactivates the face <A>i</A>.
 If a face is deactivated, then the face is not shown in the animation and will not be written in the file.
 The method <K>DeactivateFace</K>(<A>complex</A>, <A>printRecord</A>) deactivates all faces of <A>complex</A>.
 By default, all faces are activated.
<P/>
 </Description>
</ManSection>

<Subsection Label="Section_NormalsMaterial">
<Heading>NormalsMaterial</Heading>
There is the possibility to render the faces of the surface with not in the usual way but by a so called normalsMaterial. If switched on this material computes the colour of any face in real time with regards to its normal vector towards the camera. This means it computes the angle between the normal of the considered face and the camera and maps it to a smooth colour transition. As a result usually differently coloured faces have different normals. This can especially help when studying complexes with intersecting faces.
To turn this material on, just toggle the corresponding box in the GUI.
Consider the following example from before:

<Alt Only="HTML">&lt;/br>&lt;img src="../images/Octahedron_normalsMaterial.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_normalsMaterial.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_normalsMaterial.png]</Alt>

</Subsection>

</Section>


<Section Label="Section_basicCommands">
<Heading>Basic Commands</Heading>
In this section the options that can be defined by the <A>printRecord</A> will be described. The most important one is how to set coordinates.

<ManSection Label="SetVertexCoordinates3D">
  <Oper Arg="complex, coordinates[, printRecord]" Name="SetVertexCoordinates3D" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="complex, coordinates[, printRecord]" Name="SetVertexCoordinates3DNC" Label="for IsTriangularComplex, IsList, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 Let <A>complex</A> be a triagonal complex and <A>coordinates</A> a list of lists, where <A>coordinates[i] = [x,y,z]</A> for floats <A>x, y, z</A>. The optional argument <A>printRecord</A> has to be a record. This function saves the given list of 3D-coordinates <A>coordinates</A> in the given print record or a new one if non is provided. The list <A>coordinates</A> has to have entries that are a list <A>[x,y,z]</A> of three floats. If the format of the <A>coordinates</A> is not correct, an error is shown. The NC-version does not check the coordinate format.
<P/>
 </Description>
</ManSection>
Note: for using parameterised vertex coordinates see <Ref Subsect="Section_ParameterizedCoordinates"/>.

<ManSection Label="GetVertexCoordinates3D">
  <Oper Arg="complex, vertex, printRecord" Name="GetVertexCoordinates3D" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="complex, vertex, printRecord" Name="GetVertexCoordinates3DNC" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a list of lists with three floats
</Returns>
 <Description>
This function returns the 3D-coordinates from the print record of the vertex <A>vertex</A> from <A>complex</A>. The 3D-coordinates of vertex <A>vertex</A> has to have the format <A>[x,y,z]</A>. If the format of the <A>coordinates</A> is not correct, then an error is shown. This can happen, if the NC version is used to store the 3D-coordinates. The NC-version does not check the coordinate format saved in the print record. For using parameterised coordinates (see <Ref Subsect="Section_ParameterizedCoordinates"/>) it is necessary to use the NC version, as the parameterized coordinates are store in GAP as strings.
<P/>
 </Description>
</ManSection>

As decribed before the next important method is the one generating the animations.
<ManSection Label="DrawComplexToJavaScript">
  <Oper Arg="complex, filename, printRecord" Name="DrawComplexToJavaScript" Label="for IsTriangularComplex, IsString, IsRecord"/>
  <Returns>
    the print record
  </Returns>
  <Description>
  This method writes the provided data to animate the triangular complex in an <A>.html</A> file called <A>filename</A> into the current working directory. This animation of the complex can be viewed via a browser that in turn runs JavaScript.<Br/>
  An introduction how to use this method with an example can be found at the start of Section <Ref Sect="Section_QuickStart"/>. 
  <P/>
  Note:
  <List>
    <Item>
      If the given string <A>fileName</A> does not end in <E>.html</E> the ending
      <E>.html</E> will be added to it.
    </Item>
    <Item>
      If a file named <A>filename</A> already exists in the current working directory, it will be overwritten without asking. If you do not have permission to write in that file, this method will throw an error.
    </Item>
    <Item>
      The animation is determined by the given <A>printRecord</A>, which has to be a record.
    </Item>
  </List>
  <P/>
  To use these methods it is necessary to set the 3D-coordinates of the vertices of the surface (see <K>SetVertexCoordinates3D</K>) otherwise the function will throw an error that the coordinates are not in the right format.
  <P/>
  </Description>
</ManSection>

Note, it is also possible to animate simplicial surfaces whose vertices, edges and faces are not given by a dense list <K>[1..n]</K>. For example the function <K>SetVertexCoordinates3D</K> allows a list of 3D-coordinates as input that is not dense. But the usage of non-dense lists only works in the case that the 3D-coordinate of vertex <K>i</K> is stored in the <K>i</K>-th position of the given list.
<P/>
<Example><![CDATA[
gap> oneFace:=SimplicialSurfaceByDownwardIncidence([,[3,7],,[7,10],,[3,10]],
> [,,[2,4,6]]);;
gap> Vertices(oneFace);
[ 3, 7, 10 ]
gap> coor:=[];;
gap> coor[3]:=[1,0,0];;coor[7]:=[0,1,0];;coor[10]:=[0,0,1];;
gap> printRecord:=SetVertexCoordinates3D(oneFace,coor,rec());;
gap> DrawComplexToJavaScript(oneFace,"OneFace_animating",printRecord);
rec( edgeThickness := 0.03, 
 vertexCoordinates3D := [ ,, [ 1, 0, 0 ],,,, [ 0, 1, 0 ],,, [ 0, 0, 1 ] ] )
]]></Example>

<P/>
<Alt Only="HTML">&lt;/br>&lt;img src="../images/OneFace_animated.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/OneFace_animated.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/OneFace_animated.png]</Alt>

</Section>

<Section Label="Section_Colouring">
<Heading>Colouring</Heading>

 In this section, we describe how to colour the animation of a triangular complex. The colours are stored in hexadecimal format, which starts with 0x.
 The following objects can be coloured:
 <Enum>
   <Item>Vertices (The default colour is 0xF58137, an orange hue. See <Ref Subsect="SetVertexColours"/>)</Item>
   <Item>Edges (The default colour is 0x000000, black. See <Ref Subsect="SetEdgeColours"/>)</Item>
   <Item>Faces (The default colour is 0x049EF4, a light blue hue. See <Ref Subsect="SetFaceColours"/>)</Item>
   <Item>Innercircles. See <Ref Subsect="Section_InnerCircles"/></Item>
 </Enum>
 Here is a brief colouring example:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := SetVertexColours(oct,
> ListWithIdenticalEntries(NumberOfVertices(oct), "0x00FF00"), printRecord);;
gap> printRecord := SetVertexColour(oct, 3, "0xFF0000", printRecord);;
gap> List([1..NumberOfVertices(oct)], i -> GetVertexColour(oct, i, printRecord));
[ "0x00FF00", "0x00FF00", "0xFF0000", "0x00FF00", "0x00FF00", "0x00FF00" ]
gap> DrawComplexToJavaScript(oct, "octahedron-vertex-colours.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;/br>&lt;img src="../images/Octahedron_VertexColors.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_VertexColors.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_VertexColors.png]</Alt>


<ManSection Label="SetVertexColours">
  <Oper Arg="complex, newColoursList, printRecord" Name="SetVertexColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="complex, i, colour, printRecord" Name="SetVertexColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetVertexColour</K>(<A>complex</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of vertex <A>i</A> to <A>colour</A>. The method <K>SetVertexColours</K>(<A>complex</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all vertices of <A>complex</A>. That means the method sets the colour of vertex <A>j</A> to <A>newColoursList[j]</A>. The default colour for all vertices is 0xF58137, an orange hue. This colour is shown as a small sphere around the vertex with the option in the GUI to change the radius.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetVertexColours">
  <Oper Arg="complex, printRecord" Name="GetVertexColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="GetVertexColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a (list) of colour values in the format explained here: <Ref Subsect="Section_Colouring"/>
</Returns>
 <Description>
 The method <K>GetVertexColour</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) returns the colour of vertex <A>i</A>. The method <K>GetVertexColours</K>(<A>complex</A>, <A>printRecord</A>) returns the colours for all vertices of <A>complex</A> as a list <A>colours</A>, where the colour of vertex <A>j</A> is <A>colours[j]</A>. The default colour for all vertices is 0xF58137, an orange hue.
<P/>
 </Description>
</ManSection>


<ManSection Label="SetEdgeColours">
  <Oper Arg="complex, newColoursList, printRecord" Name="SetEdgeColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="complex, i, colour, printRecord" Name="SetEdgeColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetEdgeColour</K>(<A>complex</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of edge <A>i</A> to <A>colour</A>. The method <K>SetEdgeColours</K>(<A>complex</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all edges of <A>complex</A>. That means the method sets the colour of edge <A>j</A> to <A>newColoursList[j]</A>. The default colour for all edges is 0x000000, black.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetEdgeColours">
  <Oper Arg="complex, printRecord" Name="GetEdgeColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="GetEdgeColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>GetEdgeColour</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) returns the colour of edge <A>i</A>. The method <K>GetEdgeColours</K>(<A>complex</A>, <A>printRecord</A>) returns the colours for all edges of <A>complex</A> as a list <A>colours</A>, where the colour of edge <A>j</A> is <A>colours[j]</A>.
 The default colour for all edges is 0x000000, black.
<P/>
 </Description>
</ManSection>


<ManSection Label="SetFaceColours">
  <Oper Arg="complex, newColoursList, printRecord" Name="SetFaceColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="complex, i, colour, printRecord" Name="SetFaceColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetFaceColour</K>(<A>complex</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of face <A>i</A> to <A>colour</A>. The method <K>SetFaceColours</K>(<A>complex</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all faces of <A>complex</A>. That means the method sets the colour of face <A>j</A> to <A>newColoursList[j]</A>. The default colour for all faces is 0x049EF4, a light blue hue.<Br/>
 It is also possible to set the colour to a so called <A>normalsMaterial</A>, Section <Ref Subsect="Section_NormalsMaterial"/> for an explanation.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetFaceColours">
  <Oper Arg="complex, printRecord" Name="GetFaceColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="GetFaceColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a (list) of colour values in the format explained here: <Ref Subsect="Section_Colouring"/>
</Returns>
 <Description>
 The method <K>GetFaceColour</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) returns the colour of face <A>i</A>. The method <K>GetFaceColours</K>(<A>complex</A>, <A>printRecord</A>) returns the colours for all faces of <A>complex</A> as a list <A>colours</A>, where the colour of face <A>j</A> is <A>colours[j]</A>. The default colour for all faces is 0x049EF4, a light blue hue.
<P/>
 </Description>
</ManSection>

</Section>


<Section Label="Section_InnerCircles">
<Heading>Inner Circles</Heading>
Inner circles are defined for triangular faces. In the animation, they are circles within the face that touch each of the three edges in exactly one point, centered at the incenter. By default the innercircles are active but not visible and can be toggled on in the GUI. If the output file should be smaller it can help to disable these as they will not be written into the file if disabled.
<P/>
Note that it is possible to activate and deactivate the innercircles of individual faces. Additionally it is possible to colour any (sub-)set of the circles other than the default, which is black. In the GUI there is an option to change the width of the drawn circles.
<P/>
As an example, consider the octahedron generated as before:

<Alt Only="HTML">&lt;/br>&lt;img src="../images/Octahedron_InnerCircle.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_InnerCircle.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_InnerCircle.png]</Alt>

Or it is possible to make all other objects invisible via the GUI and only show the innercircles as done here:
<Alt Only="HTML">&lt;/br>&lt;img src="../images/Octahedron_InnerCircle_transparent.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_InnerCircle_transparent.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_InnerCircle_transparent.png]</Alt>

<ManSection Label="ActivateInnerCircles">
  <Oper Arg="complex, printRecord" Name="ActivateInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="ActivateInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="IsInnerCircleActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>ActivateInnerCircles</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) activates the inner circle of face <A>i</A>. The method <K>ActivateInnerCircle</K>(<A>complex</A>, <A>printRecord</A>) activates all inner circles of <A>complex</A>. If an inner circle is active, then it is displayed in the animation. By default, the inner circles are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateInnerCircles">
  <Oper Arg="complex, printRecord" Name="DeactivateInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="DeactivateInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>DeactivateInnerCircles</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) deactivates the inner circle of face <A>i</A>. The method <K>DeactivateInnerCircle</K>(<A>complex</A>, <A>printRecord</A>) deactivates all inner circles of <A>complex</A>. If an inner circle is deactivated, then it is not shown in the animation and will not be written into the file. By default, the inner circles are activated.
<P/>
 </Description>
</ManSection>

It is also possible to set colours for (subsets of) innercircles. This can be done with the following:
<ManSection Label="SetCircleColours">
  <Oper Arg="complex, newColoursList, printRecord" Name="SetCircleColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="complex, i, colour, printRecord" Name="SetCircleColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetCircleColour</K>(<A>complex</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour for the inner circle of face <A>i</A>. The method <K>SetCircleColours</K>(<A>complex</A>, <A>newColoursList</A>, <A>printRecord</A>) sets the colour for all inner circles of <A>complex</A>. That means the method sets the colour of the inner circle of face <A>j</A> to <A>newColoursList[j]</A>. The default colour is 0x000000, black.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetCircleColours">
  <Oper Arg="complex, printRecord" Name="GetCircleColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="GetCircleColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>GetCircleColour</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) returns the colour for the inner circle of face <A>i</A>. The method <K>GetCircleColours</K>(<A>complex</A>, <A>printRecord</A>) returns the colour for all inner circles of <A>complex</A> as a list <A>colours</A>, where the colour of the inner circle of face <A>j</A> is <A>colours[j]</A>. The default colour is 0x000000, black.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_NormalsInnerCircles">
<Heading>Normals of Inner Circles</Heading>

<P/>
A normal of an inner circle (compare Section <Ref Sect="Section_InnerCircles"/>) is a line intersecting the the incenter of a triangular face orthogonally and extends orthogonally w.r.t. the face in both directions.
<P/>
By default the normals of inner circles are active but invisible and can be toggled on in the GUI. To make the output files smaller it can help to disable them.

Consider the example from before:
<Alt Only="HTML">&lt;/br>&lt;img src="../images/Octahedron_NormalsOfInnerCircle.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_NormalsOfInnerCircle.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_NormalsOfInnerCircle.png]</Alt>

<ManSection Label="ActivateNormalOfInnerCircles">
  <Oper Arg="complex, printRecord" Name="ActivateNormalOfInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="ActivateNormalOfInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="IsNormalOfInnerCircleActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>ActivateNormalOfInnerCircles</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) activates the normal of the inner circle of face <A>i</A>. The method <K>ActivateNormalOfInnerCircle</K>(<A>complex</A>, <A>printRecord</A>) activates all normals of all inner circles of <A>complex</A>. If a normal is active, then the normal is written to the file.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateNormalOfInnerCircles">
  <Oper Arg="complex, printRecord" Name="DeactivateNormalOfInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, i, printRecord" Name="DeactivateNormalOfInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>DeactivateNormalOfInnerCircles</K>(<A>complex</A>, <A>i</A>, <A>printRecord</A>) deactivates the normal of the inner circle of face <A>i</A>. The method <K>DeactivateNormalOfInnerCircle</K>(<A>complex</A>, <A>printRecord</A>) deactivates all normals of the inner circles of <A>complex</A>. If a normal is deactivated, then the normal is not shown in the animation.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_ParameterizedCoordinates">
<Heading>Parameterised Coordinates</Heading>
It is possible to have the coordinates of the animation parameterized, i.e. they depend on a parameter that then gets controlled by the GUI. For this consider the following example:

<Log><![CDATA[
gap> tet := Tetrahedron();;
gap> verticesPositions := [ [ "a*b", -1/Sqrt(3.), -1/Sqrt(6.) ], 
> [ "b**(1/2)", -1/Sqrt(3.), -1/Sqrt(6.) ], 
> [ 0, 2/Sqrt(3.) , -1/Sqrt(6.) ], 
> [ 0, 0, 3/Sqrt(6.) ] ];;

gap> printRecord := SetVertexCoordinatesParameterized(tet, verticesPositions, rec());
gap> params := [["a", 0, [-1,1]], ["b", 5, [0,10]]];
gap> printRecord := SetVertexParameters(tet, params, printRecord);

gap> DrawComplexToJavaScript(tet, "tet-param-lines.html", printRecord);
]]></Log>

There are two steps to set up such an animation:
<Enum>
  <Item>Set the coordinates via the <A>SetVertexCoordinatesParameterized</A> command</Item>
  <Item>Set the range(s) of the parameters that should be available in the GUI via <A>SetVertexParameters</A></Item>
</Enum>
Note: as the computations are performed on a JavaScript level the appropriate syntax has to be used.

<ManSection Label="SetVertexCoordinatesParameterized">
  <Oper Arg="complex, coordinates[, printRecord]" Name="SetVertexCoordinatesParameterized" Label="for IsTriangularComplex, IsList, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 Save the given list of 3D-coordinates <A>coordinates</A> in the given or an empty print record if non is provided. The list <A>coordinates</A> has to have entries that are a list <A>[x,y,z]</A> of three floats or strings in case of parameters. This does not check for correctness.
<P/>
 </Description>
</ManSection>

<ManSection Label="SetVertexParameters">
  <Oper Arg="complex, parameters, printRecord" Name="SetVertexParameters" Label="for IsTriangularComplex, IsList, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 Save the given list of ranges of the parameters. They have to be provided in the format <A>[["nameofParameterA", initialValueOfA, [minA, maxA]], ["nameofParameterB", initialValueOfB, [minB, maxB]]]</A>
<P/>
 </Description>
</ManSection>

</Section>

<Section Label="Section_LineThickness">
<Heading>Variable Line Width</Heading>
Sometimes the width of the edges should be different from the default one. For this there are three simple commands that enable this functionality in the GUI. <Br/>
Note: this can be computationally hard, so if the performance drops it might be good to disable it.

<ManSection Label="LineWidth">
  <Oper Arg="complex, printRecord" Name="ActivateLineWidth" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, printRecord" Name="DeactivateLineWidth" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, printRecord" Name="IsLineWidth" Label="for IsTriangularComplex, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 (De-)activate the variable line width, controllable by the GUI. 
<P/>
 </Description>
</ManSection>

For this, consider the following example:

<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := ActivateLineWidth(oct, printRecord);;
gap> DrawComplexToJavaScript(oct, "octahedron_lineWidth.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;/br>&lt;img src="../images/Octahedron_LineWidth.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/Octahedron_LineWidth.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_LineWidth.png]</Alt>

</Section>

<Section Label="Section_PerformanceOverlay">
<Heading>Performance Overlay</Heading>
When running big animations and especially when features like the variable line width are enabled, the performance of the animation can become a problem. To get more precise information about the current performance and memory usage there is the option to show it in the corner. If clicked it switches trough the following modes: FPS (Frames per second), milliseconds it took to render the last frame and megabytes of memory used to show the current simulation. It looks as following:

<Alt Only="HTML">&lt;/br>&lt;img src="../images/PerformanceOverlay-FPS.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\begin{center}\includegraphics{../images/PerformanceOverlay-FPS.png}\end{center}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/PerformanceOverlay-FPS.png]</Alt>

As this option is mainly used for debugging it is disabled by default and can be enabled with the following commands:

<ManSection Label="LineWidth">
  <Oper Arg="complex, printRecord" Name="ActivatePerformanceOverlay" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, printRecord" Name="DeactivatePerformanceOverlay" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="complex, printRecord" Name="IsPerformanceOverlay" Label="for IsTriangularComplex, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 (De-)activate the performance overlay, displayed in the corner of the animation. 
<P/>
 </Description>
</ManSection>

Here is a simple example how to use the functionality:

<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := ActivatePerformanceOverlay(oct, printRecord);;
gap> DrawComplexToJavaScript(oct, "octahedron_performanceOverlay.html", printRecord);;
]]></Log>
The output will have the graph as shown in the pictures above in the top left corner.<Br/>
For this function we use the <A>stats.js</A> extension for <A>three.js</A> which can be found here: <URL>https://github.com/mrdoob/stats.js</URL>.

</Section>

</Chapter>

