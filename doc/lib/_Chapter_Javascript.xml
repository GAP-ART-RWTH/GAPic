<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="Chapter_AnimationJavaScript">
<Heading>Animating surfaces with Java Script</Heading>

<P/>
 This chapter deals with animating simplicial surfaces via Javascript
 using three.js, see <URL>https://threejs.org/</URL>. Currently we are using r148.
<Section Label="Section_LabelIntroductionAndQuickStartAnimating">
<Heading>Introduction and Quick Start</Heading>

 This section contains a minimal example by animating an octahedron and shows the general animation workflow.
 To construct an octahedron, we only need to specify the 3D-coordinates of the vertices.
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> DrawComplexToJavascript(oct, "octahedron.html", printRecord);;
]]></Log>


 Now, your working directory should contain a file "octahedron.html". Here is an image of the animation:<Br/>

<Alt Only="HTML">&lt;img src="../images/Octahedron_animated.png">&lt;/img>&lt;/br></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_animated.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_animated.png]</Alt><Br/>


 The philosophy of the code presented in this chapter is as follows:
 The main method <K>DrawComplexToJavascript</K> (Section <Ref Sect="Section_LabelCoordinatesAndCoreFunctionality"/>)
 animates the surfaces using the configuration saved in the so called  <A>printRecord</A>,
 e.g. the 3D-coordinates (lists with three float entries) of the vertices.
 It is necessary that the printRecord contains the 3D-coordinates of each vertex of the surface which should be animated.
 Based on the 3D-coordinates of the vertices, the surface is placed in the animation.
 Therefore, a typical workflow to animate a surfaces looks like this:
 <Enum>
   <Item>Construct the surface, e.g. the octahedron above.</Item>
   <Item>Configure your animation using the methods in the Sections
   <Ref Subsect="Section_Visibility"/> and <Ref Subsect="Section_LabelColouring"/>.</Item>
   <Item>Write your animation to a file calling the main method <K>DrawComplexToJavascript</K>
        (see Section <Ref Sect="Section_LabelCoordinatesAndCoreFunctionality"/>).</Item>
 </Enum>
 The the method <K>DrawComplexToJavascript</K>(<Ref Subsect="DrawComplexToJavascript"/>) creates and html file in your current location.
 The file can be opened with most browsers and then the surface is shown as a 3D render with some manipulation options. 
 Because we load the three.js dependecies (and three.js itself) from a CDN (content delivery network) it requires an active internet connection.
</Section>


<Section Label="Section_output">
<Heading>Output files and the GUI</Heading>

 The files generated by <K>DrawComplexToJavascript</K> have some options that can be changed live in the html file. 
 These are in the graphical user interface (GUI). Here is an example:
<Alt Only="HTML">&lt;img src="../images/GUI.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/GUI.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/GUI.png]</Alt><Br/>

 Here you can change the following:
 <Enum>
   <Item>The speed of rotation in the X, Y and Z direction</Item>
   <Item>The transparency of the faces which are enabled</Item>
   <Item>Show the edges according to visibility and colour</Item>
   <Item>The visibility of the active edges and their respective labels. More in <Ref Subsect="Section_Visibility"/></Item>
   <Item>The size the vertices are show with</Item>
   <Item>Switch to normalsMaterial. More in <Ref Subsect="Section_NormalsMaterial"/></Item>
   <Item>Optional: Parameters set for the coordinates. More in <Ref Subsect="Section_ParameterizedCoordinates"/></Item>
   <Item>Intersection Planes. More in <Ref Subsect="Subsection_IntersectionPlanes"/></Item>
 </Enum>
 This GUI is implemented using the dat.GUI package from three.js.  
 <Subsection Label="Subsection_IntersectionPlanes">
 <Heading>Intersection Planes</Heading>
  In the GUI there is the option for so called intersection planes. These are three axis aligned planes, that intersect the complete animation and only show one of the sides. <Br/>
  This allows to look into the animation and can be very helpful for example if there are selfintersections or a complex gets very big.<Br/>
  To activate any plane, toggle the respective checkbox in the GUI. Directly underneath, there is a slider to adjust where the plane should intersect the animation. <Br/>
  If there are not parameterized vertex coordinates (<Ref Subsect="Section_ParameterizedCoordinates"/>) the sliders are automatically adjusted so you can intersect the whole complex. If you want more precision, either make the GUI larger by dragging in the left of the GUI or change the slider by typing a number in the field next to it.<Br/>
  If there are coordinates which are parameterized or you want to change the range of the planes for another reason, it is possible to set them manually:
  </Subsection>
  <ManSection Label="SetPlaneRange">
  <Oper Arg="surface, ranges, printRecord" Name="SetPlaneRange" Label="for IsTriangularComplex, IsList, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 Change the range of the intersection planes by giving a list of the <A>ranges</A> in the following format: <A>[[minX, maxX],[minY, maxY],[minZ, maxZ]]</A>
<P/>
 </Description>
</ManSection>

<ManSection Label="GetPlaneRange">
  <Oper Arg="surface, printRecord" Name="GetPlaneRange" Label="for IsTriangularComplex, IsRecord"/>
 <Returns>a list of lists
</Returns>
 <Description>
 Returns the plane ranges set in <A>SetPlaneRange</A> in the format <A>[[minX, maxX],[minY, maxY],[minZ, maxZ]]</A> or <A>fail</A> if they are not set (i.e. automatic).
<P/>
 </Description>
</ManSection>

</Section>


<Section Label="Section_LabelCoordinatesAndCoreFunctionality">
<Heading>Coordinates and Core Functionality</Heading>

 This section describes the animation method and how to define vertex coordinates.
 Before the animation (see <K>DrawComplexToJavascript</K> <Ref Subsect="DrawComplexToJavascript"/>) can be drawn,
 it is necessary to specify the 3D-coordinates (which means, the [x,y,z] coordinates) of all vertices
 of the surface which should be animated (see <K>SetVertexCoordinates3D</K> <Ref Subsect="SetVertexCoordinates3D"/>).
<P/>
 After setting the vertex coordinates, the location of the edges in <M>\mathbb{R}^3</M> has to be derived.
 By default, the method <K>DrawComplexToJavascript</K>(<Ref Subsect="DrawComplexToJavascript"/>)
 always calculates the edge locations depending on the current vertices positions.
 If you want to avoid that, you can use the method <K>DrawComplexToJavascriptCalculate</K>(<Ref Subsect="DrawComplexToJavascript"/>)
 and set the last parameter to false. In this case, only the first call of the method computes the edge locations.
 Using this method can make the animation inconsistent if the coordinates of the vertices have changed but the edge locations have stayed the same.
<P/>
 The animation draws all faces and a wireframe for them individually. This wireframe can be enabled and disabled in the user interface.
 The vertices will be drawn as small spheres, with the corresponding number is displayed above the vertex. 
 These will be only drawn if they are active, see  <K>ActivateVertices</K> <Ref Subsect="ActivateVertices"/>
<P/>
 Note, it is also possible to animate simplicial surfaces whose vertices,
 edges and faces are not given by a dense list <K>[1..n]</K>.
 For example the function <K>SetVertexCoordinates3D</K> allows a list of
 3D-coordinates as input that is not dense. But this only works in the case 
 that the 3D-coordinate of vertex <K>i</K> is stored in the <K>i</K>-th
 position of the given list.
<P/>
<Example><![CDATA[
gap> oneFace:=SimplicialSurfaceByDownwardIncidence([,[3,7],,[7,10],,[3,10]],
> [,,[2,4,6]]);;
gap> Vertices(oneFace);
[ 3, 7, 10 ]
gap> coor:=[];;
gap> coor[3]:=[1,0,0];;coor[7]:=[0,1,0];;coor[10]:=[0,0,1];;
gap> printRecord:=SetVertexCoordinates3D(oneFace,coor,rec());;
gap> DrawComplexToJavascript(oneFace,"OneFace_animating",printRecord);
rec( edgeThickness := 0.03, 
 vertexCoordinates3D := [ ,, [ 1, 0, 0 ],,,, [ 0, 1, 0 ],,, [ 0, 0, 1 ] ] )
]]></Example>


<P/>
<Alt Only="HTML">&lt;img src="../images/OneFace_animated.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/OneFace_animated.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/OneFace_animated.png]</Alt>

<P/>
<ManSection Label="SetVertexCoordinates3D">
  <Oper Arg="surface, coordinates[, printRecord]" Name="SetVertexCoordinates3D" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, coordinates[, printRecord]" Name="SetVertexCoordinates3DNC" Label="for IsTriangularComplex, IsList, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 Save the given list of 3D-coordinates <A>coordinates</A> in the given or an empty print record.
 The list <A>coordinates</A> has to have entries that are a list <A>[x,y,z]</A> of three floats.
 If the format of the <A>coordinates</A> is not correct, then an error is shown.
 The NC-version does not check the coordinate format.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetVertexCoordinates3D">
  <Oper Arg="surface, vertex, printRecord" Name="GetVertexCoordinates3D" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, vertex, printRecord" Name="GetVertexCoordinates3DNC" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a list
</Returns>
 <Description>
 Extract the 3D-coordinates from the print record of the vertex <A>vertex</A> from <A>surface</A>.
 The 3D-coordinates of vertex <A>vertex</A> has to have the format <A>[x,y,z]</A>.
 If the format of the <A>coordinates</A> is not correct, then an error is shown.
 This can happen, if the NC version is used to store the 3D-coordinates.
 The NC-version does not check the coordinate format saved in the print record.
<P/>
 </Description>
</ManSection>


<ManSection Label="DrawComplexToJavascript">
  <Oper Arg="surface, filename, printRecord" Name="DrawComplexToJavascript" Label="for IsTriangularComplex, IsString, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 These methods animate the <A>surface</A> as a html file <A>filename</A> in JavaScript into the working directory.
 The animation can be opened and watched with most browsers.
 An introduction to the use of this method with an example
 can be found at the start of section
 <Ref Sect="Section_LabelIntroductionAndQuickStartAnimating"/>.
<P/>
<List>
<Item>
If the given <A>fileName</A> does not end in <E>.html</E> the ending
   <E>.html</E> will be added to it.
</Item>
<Item>
The given file will be overwritten without asking if it already exists.
   If you don't have permission to write in that file, this method will
   throw an error.
</Item>
<Item>
The particulars of the drawing are determined by the
   given <A>printRecord</A>.
</Item>
</List>
<P/>
 To use these methods it is necessary to set the 3D-coordinates 
 of the vertices of the surface (see <K>SetVertexCoordinates3D</K>).
<P/>
 There are two parameters to change the output of this method.
 There are the following classes of parameters:
<List>
<Item>
<E>Visibility</E>
   (<Ref Subsect="Section_Visibility"/>): Change the
   visibility of vertices, edges and faces.
</Item>
<Item>
<E>Colours</E>
   (<Ref Subsect="Section_LabelColouring"/>): Change the
   colours of vertices, edges and faces.
</Item>
</List>
<P/>
 There are also options for inner circles (<Ref Subsect="Section_LabelInnerCirclesAnimating"/>)
 and normals of inner circles (<Ref Subsect="Section_LabelNormalsInnerCirclesAnimating"/>).
<P/>
 </Description>
</ManSection>


<ManSection Label="CalculateParametersOfEdges">
  <Oper Arg="surface, printRecord" Name="CalculateParametersOfEdges" Label="for IsSimplicialSurface, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 This method calculates the parameters of the edges (centre, length, angles relative to x-direction) based on the
 coordinates of the vertices and saves those to the print record.
 </Description>
</ManSection>


</Section>


<Section Label="Section_Visibility">
<Heading>Visibility</Heading>

 A simplicial surface is described through its vertices, edges, and faces. But sometimes, not all of them should be visible.
 Therefore, it is possible to make the following visible and invisible:
 <Enum>
   <Item>Vertices (see <Ref Subsect="ActivateVertices"/>) </Item>
   <Item>Edges (The default colour is 0x000000, black. See <Ref Subsect="SetEdgeColours"/>)</Item>
   <Item>Faces (see <Ref Subsect="ActivateFaces"/>) </Item>
 </Enum>
 By default, all vertices, and faces are visible. For the visibility of the edges, there is a wireframe option in the GUI of the output file. 
 It is also possible in the GUI to change the transparency of all faces. Otherwise all vertices which are active will be shown. 
 Both can be changed live and updates the shown render immediately. 
 The following example shows an animation with invisible vertices.
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := DeactivateVertices(oct, printRecord);;
gap> DrawComplexToJavascript(oct, "octahedron.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_animatedWithoutVertices.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_animatedWithoutVertices.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_animatedWithoutVertices.png]</Alt><Br/>

 It is also possible that some vertices are visible and others are not.
 We illustrade this functionality by animating an octahedron with none but the vertices 2 and 3 visible.
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := DeactivateVertices(oct, printRecord);;
gap> printRecord := ActivateVertex(oct, 2, printRecord);;
gap> printRecord := ActivateVertex(oct, 3, printRecord);;
gap> List([1..NumberOfVertices(oct)], i -> IsVertexActive(oct, i, printRecord));
[ false, true, true, false, false, false ]
gap> DrawComplexToJavascript(oct, "octahedron.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_animatedWithoutSomeVertices.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_animatedWithoutSomeVertices.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_animatedWithoutSomeVertices.png]</Alt><Br/>


<ManSection Label="ActivateVertices">
  <Oper Arg="surface, printRecord" Name="ActivateVertices" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateVertex" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsVertexActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateVertex</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the vertex <A>i</A>.
 If a vertex is active, then the vertex is shown in the animation as a node with the number <A>i</A>.
 The method <K>ActivateVertices</K>(<A>surface</A>, <A>printRecord</A>) activates all vertices of <A>surface</A>.
 By default, all vertices are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateVertices">
  <Oper Arg="surface, printRecord" Name="DeactivateVertices" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateVertex" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateVertex</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the vertex <A>i</A>.
 If a vertex is inactive, then the vertex is not shown separately.
 The method <K>DeactivateVertices</K>(<A>surface</A>, <A>printRecord</A>) deactivates all vertices of <A>surface</A>.
 By default, all vertices are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="ActivateFaces">
  <Oper Arg="surface, printRecord" Name="ActivateFaces" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateFace" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsFaceActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>ActivateFace</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the face <A>i</A>.
 If a face is active, then the face is shown in the animation as an area.
 The method <K>ActivateFaces</K>(<A>surface</A>, <A>printRecord</A>) activates all faces of <A>surface</A>.
 By default, all faces are activated.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateFaces">
  <Oper Arg="surface, printRecord" Name="DeactivateFaces" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateFace" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>the updated print record
</Returns>
 <Description>
 The method <K>DeactivateFace</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the face <A>i</A>.
 If an face is inactive, then the face is not shown in the animation as an area.
 The method <K>DeactivateFace</K>(<A>surface</A>, <A>printRecord</A>) deactivates all faces of <A>surface</A>.
 By default, all faces are activated.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_LabelColouring">
<Heading>Colouring</Heading>

 In this section, we describe how to colour the animation. The colours are stored in hexadecimal format, which starts with 0x.
 The following possibilities are available:
 <Enum>
   <Item>Vertices (The default colour is 0xF58137, an orange hue. See <Ref Subsect="SetVertexColours"/>)</Item>
   <Item>Faces (The default colour is 0x049EF4, a light blue hue. See <Ref Subsect="SetFaceColours"/>)</Item>
 </Enum>
 Some colours can also be referred to by strings, namely:
<List>
<Item>
Black = 0x000000
</Item>
<Item>
Blue = 0x0000FF
</Item>
<Item>
Brown = 0xA52A2A
</Item>
<Item>
Green = 0x008000
</Item>
<Item>
Orange = 0xFFA500
</Item>
<Item>
Purple = 0x800080
</Item>
<Item>
Pink = 0xFFC0CB
</Item>
<Item>
Red = 0xFF0000
</Item>
<Item>
White = 0xFFFFFF
</Item>
<Item>
Yellow = 0xFFFF00
</Item>
</List>
 Here is a brief colouring example:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := SetVertexColours(oct,
> ListWithIdenticalEntries(NumberOfVertices(oct), "green"), printRecord);;
gap> printRecord := SetVertexColour(oct, 3, "red", printRecord);;
gap> List([1..NumberOfVertices(oct)], i -> GetVertexColour(oct, i, printRecord));
[ "green", "green", "red", "green", "green", "green" ]
gap> DrawComplexToJavascript(oct, "octahedron.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_EdgeColors.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_EdgeColors.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_EdgeColors.png]</Alt><Br/>


<ManSection Label="SetVertexColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetVertexColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetVertexColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetVertexColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of vertex <A>i</A> to <A>colour</A>.
 The method <K>SetVertexColours</K>(<A>surface</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all vertices of <A>surface</A>.
 That means the method set the colour of vertex <A>j</A> to <A>newColoursList[j]</A>.
 The default colour for all vertices is 0xF58137, an orange hue. This color will be shown as a small sphere around the vertex.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 For more information look at the start of the section <Ref Subsect="Section_LabelColouring"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetVertexColours">
  <Oper Arg="surface, printRecord" Name="GetVertexColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetVertexColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a (list) of color values in the format explained here: <Ref Subsect="Section_LabelColouring"/>
</Returns>
 <Description>
 The method <K>GetVertexColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour of vertex <A>i</A>.
 The method <K>GetVertexColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colours for all vertices of <A>surface</A>
 as a list <A>colours</A>, where the colour of vertex <A>j</A> is <A>colours[j]</A>.
 The default colour for all vertices is 0xF58137, an orange hue.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 For more information look at the start of the section <Ref Subsect="Section_LabelColouring"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="SetEdgeColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetEdgeColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetEdgeColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetEdgeColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of edge <A>i</A> to <A>colour</A>.
 The method <K>SetEdgeColours</K>(<A>surface</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all edges of <A>surface</A>.
 That means the method set the colour of edge <A>j</A> to <A>newColoursList[j]</A>.
 The default colour for all edges is 0x000000, black.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 For more information look at the start of the section <Ref Subsect="Section_LabelColouring"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetEdgeColours">
  <Oper Arg="surface, printRecord" Name="GetEdgeColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetEdgeColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>GetEdgeColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour of edge <A>i</A>.
 The method <K>GetEdgeColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colours for all edges of <A>surface</A>
 as a list <A>colours</A>, where the colour of edge <A>j</A> is <A>colours[j]</A>.
 The default colour for all edges is 0x000000, black.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 For more information look at the start of the section <Ref Subsect="Section_LabelColouring"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="SetFaceColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetFaceColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetFaceColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetFaceColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour of face <A>i</A> to <A>colour</A>.
 The method <K>SetFaceColours</K>(<A>surface</A>,<A>newColoursList</A>, <A>printRecord</A>) sets the colours for all faces of <A>surface</A>.
 That means the method set the colour of face <A>j</A> to <A>newColoursList[j]</A>.
 The default colour for all faces is 0x049EF4, a light blue hue.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 For more information look at the start of the section <Ref Subsect="Section_LabelColouring"/>.
 It is also possible to set the color to a so called normalsMaterial, more in <Ref Subsect="Section_NormalsMaterial"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetFaceColours">
  <Oper Arg="surface, printRecord" Name="GetFaceColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetFaceColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a (list) of color values in the format explained here: <Ref Subsect="Section_LabelColouring"/>
</Returns>
 <Description>
 The method <K>GetFaceColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour of face <A>i</A>.
 The method <K>GetFaceColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colours for all faces of <A>surface</A>
 as a list <A>colours</A>, where the colour of face <A>j</A> is <A>colours[j]</A>.
 The default colour for all faces is 0x049EF4, a light blue hue.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 For more information look at the start of the section <Ref Subsect="Section_LabelColouring"/>.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_LabelInnerCirclesAnimating">
<Heading>Inner Circles</Heading>

<P/>
 Inner circles are defined for triangular faces.
 In the animation, they are circles within the face that touch each edge in exactly one point.
<P/>
 The functionality concerning the inner circles is completely similar to the functionality concerning the edges.
<P/>
 By default, the inner circles are inactive.
<P/>
 The following options are implemented for inner circles:
 <Enum>
   <Item>Activate and deactivate inner circles. If an inner circle is active, then it is shown in the animation.
         (See <Ref Subsect="ActivateInnerCircles"/>)</Item>
   <Item>Set colours of inner circles for the animation. (See <Ref Subsect="SetCircleColours"/>)</Item>
 </Enum>
 For example, consider the octahedron:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := ActivateInnerCircles(oct,printRecord);;
gap> DrawComplexToJavascript(oct, "Octahedron_InnerCircle.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_InnerCircle.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_InnerCircle.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_InnerCircle.png]</Alt><Br/>


 Consider the same example if we increased the transparency of the faces:

<Alt Only="HTML">&lt;img src="../images/Octahedron_InnerCircleWithoutFaces.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_InnerCircleWithoutFaces.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_InnerCircleWithoutFaces.png]</Alt><Br/>


<ManSection Label="ActivateInnerCircles">
  <Oper Arg="surface, printRecord" Name="ActivateInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsInnerCircleActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>ActivateInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the inner circle of face <A>i</A>.
 The method <K>ActivateInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) activates all inner circles of <A>surface</A>.
 If an inner circle is active, then it is shown in the animation.
 By default, the inner circles are deactivated.
 For the description of inner circles look at <Ref Sect="Section_LabelInnerCirclesAnimating"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateInnerCircles">
  <Oper Arg="surface, printRecord" Name="DeactivateInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>DeactivateInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the inner circle of face <A>i</A>.
 The method <K>DeactivateInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) deactivates all inner circles of <A>surface</A>.
 If an inner circle is deactivated, then it is not shown in the animation.
 By default, the inner circles are deactivated.
 For the description of inner circles look at <Ref Sect="Section_LabelInnerCirclesAnimating"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="SetCircleColours">
  <Oper Arg="surface, newColoursList, printRecord" Name="SetCircleColours" Label="for IsTriangularComplex, IsList, IsRecord"/>
  <Oper Arg="surface, i, colour, printRecord" Name="SetCircleColour" Label="for IsTriangularComplex, IsPosInt, IsString, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>SetCircleColour</K>(<A>surface</A>, <A>i</A>, <A>colour</A>, <A>printRecord</A>) sets the colour for the inner circle of face <A>i</A>.
 The method <K>SetCircleColours</K>(<A>surface</A>, <A>newColoursList</A>, <A>printRecord</A>) sets the colour for all inner circles of <A>surface</A>.
 That means the method set the colour of the inner circle of face <A>j</A> to <A>newColoursList[j]</A>.
 The default colour is 0x000000, an black hue.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 Compare Section <Ref Sect="Section_LabelColouring"/> for a list of default colours.
 For the description of inner circles look at <Ref Sect="Section_LabelInnerCirclesAnimating"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="GetCircleColours">
  <Oper Arg="surface, printRecord" Name="GetCircleColours" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="GetCircleColour" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>GetCircleColour</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) returns the colour for the inner circle of face <A>i</A>.
 The method <K>GetCircleColours</K>(<A>surface</A>, <A>printRecord</A>) returns the colour for all inner circles of <A>surface</A>
 as a list <A>colours</A>, where the colour of the inner circle of face <A>j</A> is <A>colours[j]</A>.
 The default colour is 0x000000, an black hue.
 Colours are stored in the format 0xABCDEF where A,B,C,D,E,F are elements of the hexadecimal code.
 Compare Section <Ref Sect="Section_LabelColouring"/> for a list of default colours.
 For the description of inner circles look at <Ref Sect="Section_LabelInnerCirclesAnimating"/>.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_LabelNormalsInnerCirclesAnimating">
<Heading>Normals of Inner Circles</Heading>

<P/>
 A normal of an inner circle (compare Section <Ref Sect="Section_LabelInnerCirclesAnimating"/>) is a line
 intersecting the center of the incircle orthogonally or to say in other words it intersects the incenter and extends orthogonally w.r.t. the face in both directions.
<P/>
 The normal vectors of inner circles can be (de-)activated like vertices, edges, and faces.
 If the are active, they have the colour of the corresponding inner circle.
 For example, consider the octahedron:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := ActivateNormalOfInnerCircles(oct,printRecord);;
gap> DrawComplexToJavascript(oct, "Octahedron_InnerCircle.html", printRecord);;
]]></Log>

<Alt Only="HTML">&lt;img src="../images/Octahedron_NormalsOfInnerCircle.png">&lt;/img></Alt>
<Alt Only="LaTeX">\includegraphics{../images/Octahedron_NormalsOfInnerCircle.png}</Alt>
<Alt Only="Text">[Image omitted in text manual. Check doc/images/Octahedron_NormalsOfInnerCircle.png]</Alt><Br/>


 Consider the octahedron if the faces are deactivated:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := DeactivateFaces(oct,printRecord);;
gap> printRecord := ActivateNormalOfInnerCircles(oct,printRecord);;
gap> DrawComplexToJavascript(oct, "Octahedron_InnerCircle.html", printRecord);;
]]></Log>


<ManSection Label="ActivateNormalOfInnerCircles">
  <Oper Arg="surface, printRecord" Name="ActivateNormalOfInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateNormalOfInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsNormalOfInnerCircleActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>ActivateNormalOfInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) activates the normal of the inner circle of face <A>i</A>.
 The method <K>ActivateNormalOfInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) activates all normals of the inner circles of <A>surface</A>.
 If a normal is active, then the normal is shown in the animation.
 By default, the normals of inner circles are deactivated.
 For the description of normals of inner circles look at <Ref Sect="Section_LabelNormalsInnerCirclesAnimating"/>.
<P/>
 </Description>
</ManSection>


<ManSection Label="DeactivateNormalOfInnerCircles">
  <Oper Arg="surface, printRecord" Name="DeactivateNormalOfInnerCircles" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateNormalOfInnerCircle" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
 <Returns>a print record
</Returns>
 <Description>
 The method <K>DeactivateNormalOfInnerCircles</K>(<A>surface</A>, <A>i</A>, <A>printRecord</A>) deactivates the normal of the inner circle of face <A>i</A>.
 The method <K>DeactivateNormalOfInnerCircle</K>(<A>surface</A>, <A>printRecord</A>) deactivates all normals of the inner circles of <A>surface</A>.
 If a normal is deactivated, then the normal is not shown in the animation.
 By default, the normals of inner circles are deactivated.
 For the description of normals inner circles look at <Ref Sect="Section_LabelNormalsInnerCirclesAnimating"/>.
<P/>
 </Description>
</ManSection>


</Section>


<Section Label="Section_NormalsMaterial">
<Heading>NormalsMaterial</Heading>

 Currently there is the possibility to render the surface with not the normal material but a so called normalsMaterial. This material computes the color of any face live 
 with regards to it's normal vector towards the camera. That way we get a different color if two faces are not in the same orientation.
<P/>
 Consider the following example:
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord := SetFaceColour(oct, "normal", printRecord);
gap> DrawComplexToJavascript(oct, "doc/Octahedron_NormalMaterial.html", printRecord);;
]]></Log>


</Section>


<Section Label="Section_AdditionalParameters">
<Heading>Additional Parameters</Heading>

 <E> This is currently not working, check https://github.com/schnellecom/SimplicialSurfaces/issues/14 </E> 
<P/>
 The printRecord can have optional parameters to modify the output in the html file.
 In large examples it can be a hard to recognize the edges.
 For this, one can change the parameter <A>edgeThickness</A>. The default value is set to <Math>0.03</Math>. We recommend choosing a value in the range <Math>0.01-0.05</Math>.
 If the value is not set, it will be set to the default in the printRecord when <K>DrawComplexToJavascriptCalculate</K>(<Ref Subsect="DrawComplexToJavascript"/>) is called.
 An image of an octahedron with thicker edges which is produced by the following code is shown below.
<Log><![CDATA[
gap> oct := Octahedron();;
gap> verticesPositions := [
> [ 0, 0, Sqrt(2.) ],
> [ 1, 1, 0 ],
> [ 1, -1, 0 ],
> [ -1, -1, 0 ],
> [ -1, 1, 0 ],
> [ 0, 0, -Sqrt(2.) ] ];;
gap> printRecord := SetVertexCoordinates3D(oct, verticesPositions, rec());;
gap> printRecord.edgeThickness:=0.05;
gap> DrawComplexToJavascript(oct, "doc/Octahedron_ThickEdges.html", printRecord);;
]]></Log>


</Section>


<Section Label="Section_Deprecated_functions">
<Heading>Deprecated functions</Heading>

<ManSection Label="Deprecated_functions">
  <Oper Arg="surface, printRecord" Name="ActivateEdges" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="ActivateEdge" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="IsEdgeActive" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, printRecord" Name="DeactivateEdges" Label="for IsTriangularComplex, IsRecord"/>
  <Oper Arg="surface, i, printRecord" Name="DeactivateEdge" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, face, value, printRecord" Name="SetTransparencyJava" Label="for IsTriangularComplex, IsPosInt, IsFloat, IsRecord"/>
  <Oper Arg="surface, face, printRecord" Name="RemoveTransparencyJava" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, face, printRecord" Name="GetTransparencyJava" Label="for IsTriangularComplex, IsPosInt, IsRecord"/>
  <Oper Arg="surface, printRecord" Name="CalculateParametersOfInnerCircle" Label="for IsTriangularComplex, IsRecord"/>
 <Description>
 There are several methods which are deprecated with the switch to the new three.js version, they are listed below:
<P/>
 </Description>
</ManSection>


</Section>


</Chapter>

